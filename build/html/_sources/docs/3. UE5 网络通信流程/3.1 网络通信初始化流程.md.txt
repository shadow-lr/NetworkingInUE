# 3.1 UE5 网络通信初始化流程

先从`UWorld::Listen`看起，函数有一个`FURL`类型的参数，其定义如下：

需要关注的有，`Host`、`Port`，对应Ip地址和端口号，本质上根据这两个就可以实现局域网的连接通信了。
```cpp
//URL structure.
USTRUCT()
struct ENGINE_API FURL
{
    // ......
    
    // Optional hostname, i.e. "204.157.115.40" or "unreal.epicgames.com", blank if local.
    UPROPERTY()
    FString Host;

    // Optional host port.
    UPROPERTY()
    int32 Port;

    // ......
}
```
从这里我们可以得知，`NetDriver`是寄生在`UWorld`里的，也就是`UWorld`的生命周期是包含`NetDriver`的生命周期的，假如`UWorld`销毁再重新创建，`NetDriver`也会重新创建。
UE客户端和服务器的代码是存在于同一框架、流程下的，对于特定代码在哪端执行，是由宏定义去控制的。
```cpp
bool UWorld::Listen( FURL& InURL )
#if WITH_SERVER_CODE
    -> GEngine->CreateNamedNetDriver(this, NAME_GameNetDriver, NAME_GameNetDriver) 创建NetDriver
    -> NetDriver = GEngine->FindNamedNetDriver(this, NAME_GameNetDriver)
        -> NetDriver->InitListen( this, InURL, false, Error ) 虚函数
        --> UDemoNetDriver::InitListen(FNetworkNotify* InNotify, FURL& ListenURL, bool bReuseAddressAndPort, FString& Error) 回放系统
        --> UIpNetDriver::InitListen( FNetworkNotify* InNotify, FURL& LocalURL, bool bReuseAddressAndPort, FString& Error) 基于IP地址通信
        --> USteamSocketsNetDriver::InitListen(FNetworkNotify* InNotify, FURL& LocalURL, bool bReuseAddressAndPort, FString& Error) 没用过
        --> UWebSocketNetDriver::InitListen(FNetworkNotify* InNotify, FURL& LocalURL, bool bReuseAddressAndPort, FString& Error) WebSocket 网络通信
#endif // WITH_SERVER_CODE
````
列举下各个继承自`UNetDriver`类在`InitListen`函数中完成的事

#### UDemoNetDriver
```cpp
UDemoNetDriver::InitListen(FNetworkNotify* InNotify, FURL& ListenURL, bool bReuseAddressAndPort, FString& Error)
    -> UDemoNetDriver::InitBase(false, InNotify, ListenURL, bReuseAddressAndPort, Error)
        -> (UNetDriver)Super::InitBase(bInitAsClient, InNotify, URL, bReuseAddressAndPort, Error) 服务器和客户端连接设置之间的通用初始化(超时时间、DDos初始化等)
        -> UDemoNetDriver::ResetDemoState() 初始化回放系统的状态
    ->  UDemoNetConnection* Connection = NewObject<UDemoNetConnection>();
	    Connection->InitConnection(this, USOCK_Open, ListenURL, 1000000); 在服务器上创建一个连接，把他当作客户端，放进ClientConnections中
    ->  StartRecording()
    ->  SpawnDemoRecSpectator(Connection, ListenURL);
```
#### IpNetDriver
**UIpNetDriver::InitBase()** 流程相对较多，考虑了要处理尚未建立连接的客户端发来的数据包
```cpp
UIpNetDriver::InitListen(FNetworkNotify* InNotify, FURL& LocalURL, bool bReuseAddressAndPort, FString& Error)
    -> UIpNetDriver::InitBase
        -> (UNetDriver)Super::InitBase
        -> Resolver->InitBindSockets(MoveTemp(CreateAndBindSocketsFunc), InitBindFlags, SocketSubsystem, Error) 为每个Local绑定地址(ISocketSubsystem::Get()->GetLocalBindAddresses()) 创建和绑定Socket
        -> for (TSharedRef<FInternetAddr>& BindAddr : BindAddresses) 获取本地可绑定的地址，并且为每个地址都创建一个Socket，并加入到BoundSockets中
            FUniqueSocket NewSocket = CreateAndBindSocketFunc(BindAddr, Error)
            BoundSockets.Emplace(NewSocket.Release(), FSocketDeleter(NewSocket.GetDeleter()))
        -> CVar一些通过命令行设置的参数设置(为Ip地址创建接收线程、)
    -> UNetDriver::InitConnectionlessHandler() 初始化Handler用来处理，无连接状态下的数据包
```
#### WebSocketNetDriver
```cpp
UWebSocketNetDriver::InitListen(FNetworkNotify* InNotify, FURL& LocalURL, bool bReuseAddressAndPort, FString& Error)
    -> UWebSocketNetDriver::InitBase
        -> (UNetDriver)Super::InitBase
    -> UNetDriver::InitConnectionlessHandler
    -> WebSocketServer = new class FWebSocketServer();
        WebSocketServer->Init(WebSocketPort, CallBack)  初始化WebSocket服务器的信息
        WebSocketServer->Tick()
            ->  lws_service(Context, 0);    // libwebsockets.h
            ->  lws_callback_on_writable_all_protocol(Context, &Protocols[0]);
    -> ServerConnection = NULL
```

至此，`UWorld::Listen`在`Server`端完成初始化监听端口，初始化连接。

再来看看客户端的初始化流程
**NetDriver::InitConnect()** 这是一个纯虚函数，所以我们看下它子类的重载。
```cpp
// 在客户端模式下初始化网络驱动程序
ENGINE_API virtual bool InitConnect(class FNetworkNotify* InNotify, const FURL& ConnectURL, FString& Error ) PURE_VIRTUAL( UNetDriver::InitConnect, return true;);
```

#### UIpNetDriver::InitConnect
```cpp
bool UIpNetDriver::InitConnect(FNetworkNotify* InNotify, const FURL& ConnectURL, FString& Error)
    -> UIpNetDriver::InitBase(true, InNotify, ConnectURL, false, Error) // 此处不同了，第一个参数是true，而前面作为服务器InitListen里调用InitBase第一个参数是false
    -> ServerConnection = NewObject<UNetConnection>(GetTransientPackage(), NetConnectionClass); // Create new connection
        ServerConnection->InitLocalConnection(this, SocketPrivate.Get(), ConnectURL, USOCK_Pending)
        if (...)
            SocketState = ESocketState::Resolving;
    -> UNetDriver::CreateInitialClientChannels()    // 为每个ChannelDefinitons (config预先配置)
```
**UIpNetDriver::InitConnect** 做的事情是，创建了个`Connection`对象，用来当做客户端通往服务器的连接，并且根据预先的配置，在这个`Connection`上创建多个`Channel`，是个一比多的关系。

#### UDemoNetDriver::InitConnect
```cpp
bool UDemoNetDriver::InitConnect(FNetworkNotify* InNotify, const FURL& ConnectURL, FString& Error)
    -> UDemoNetDriver::InitBase(true, InNotify, ConnectURL, false, Error)
        -> UIpNetDriver::InitBase(true, InNotify, ConnectURL, false, Error)
        -> ResetDemoState()初始化回放系统状态
        -> ReplayHelper.Init(URL) 解析URL
    -> ServerConnection = NewObject<UNetConnection>(GetTransientPackage(), UDemoNetConnection::StaticClass()); 	// Playback, local machine is a client, and the demo stream acts "as if" it's the server.
	    ServerConnection->InitConnection(this, USOCK_Pending, ConnectURL, 1000000);
    -> GetReplayStreamer()->StartStreaming(Params, FStartStreamingCallback::CreateUObject(this, &UDemoNetDriver::ReplayStreamingReady)); // todo: 尚不知道此处作用
```

#### Client初始化流程

```cpp
UEngine::Browse // 解析URL，`Listen Server`启动的方式，也会经过这一步进行解析，如参数`?Listen`, `/Game/Assets/Scenes/Main`等Map
    -> UPendingNetGame::InitNetDriver
        -> UIpNetDriver::InitConnect // 接着就是上面的流程了
            -> PacketHandler::BeginHandshaking // 启动握手连接 触发Notify
                -> StatelessConnectHandlerComponent::NotifyHandshakeBegin
                    -> StatelessConnectHandlerComponent::SendInitialPacket 发送初始数据包(Header、ClientID等)
```

#### 总结

OK，到此时做个总结。